// Package openchargemap provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package openchargemap

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	APIKeyHeaderScopes       = "APIKeyHeader.Scopes"
	APIKeyQueryStringScopes  = "APIKeyQueryString.Scopes"
	UserAuthenticationScopes = "UserAuthentication.Scopes"
)

// AddressInfo Geographic position for site and (nearest) address component information.
type AddressInfo struct {
	// AccessComments Guidance for users to use or find the equipment
	AccessComments *string `json:"AccessComments,omitempty"`

	// AddressLine1 First line of nearby street address
	AddressLine1 *string `json:"AddressLine1,omitempty"`

	// AddressLine2 Second line of nearby street address
	AddressLine2 *string `json:"AddressLine2,omitempty"`

	// ContactEmail Primary contact email
	ContactEmail *string `json:"ContactEmail,omitempty"`

	// ContactTelephone1 Primary contact number
	ContactTelephone1 *string `json:"ContactTelephone1,omitempty"`

	// ContactTelephone2 Secondary contact number
	ContactTelephone2 *string `json:"ContactTelephone2,omitempty"`

	// Country Country details
	Country *Country `json:"Country,omitempty"`

	// CountryID The reference ID for the Country
	CountryID int `json:"CountryID"`

	// Distance Distance from search location, if search is around a point
	Distance *float32 `json:"Distance,omitempty"`

	// DistanceUnit Unit used for distance, 1= Miles, 2 = KM
	DistanceUnit *int `json:"DistanceUnit,omitempty"`

	// ID ID
	ID int `json:"ID"`

	// Latitude Site latitude coordinate in decimal degrees
	Latitude float32 `json:"Latitude"`

	// Longitude Site longitude coordinate in decimal degrees
	Longitude float32 `json:"Longitude"`

	// Postcode Postal code or Zipcode
	Postcode *string `json:"Postcode,omitempty"`

	// RelatedURL Optional website for more information
	RelatedURL *string `json:"RelatedURL,omitempty"`

	// StateOrProvince State or Province
	StateOrProvince *string `json:"StateOrProvince,omitempty"`

	// Title General title for this location to aid user
	Title *string `json:"Title,omitempty"`

	// Town Town or City
	Town *string `json:"Town,omitempty"`
}

// CheckinStatusType Classification for the users comment or experience using a specific charging location.
type CheckinStatusType struct {
	ID int `json:"ID"`

	// IsAutomatedCheckin If true, checkin or comment was provided by an automated system.
	IsAutomatedCheckin bool `json:"IsAutomatedCheckin"`

	// IsPositive If true, this type of checkin/comment is considered positive.
	IsPositive *bool   `json:"IsPositive,omitempty"`
	Title      *string `json:"Title,omitempty"`
}

// ConnectionInfo Details on the equipment type and power capability.
//
// If calling the API in verbose mode related models are also included in the result (e.g. ConnectionType, Level, StatusType, CurrentType)
type ConnectionInfo struct {
	// Amps EVSE supply max current in Amps
	Amps     *int    `json:"Amps,omitempty"`
	Comments *string `json:"Comments,omitempty"`

	// ConnectionType The type of end-user connection an EVSE supports.
	ConnectionType   *ConnectionType `json:"ConnectionType,omitempty"`
	ConnectionTypeID *int            `json:"ConnectionTypeID,omitempty"`

	// CurrentType Indicates the EVSE power supply type e.g. DC (Direct Current), AC (Single Phase), AC (3 Phase).
	CurrentType *SupplyType `json:"CurrentType,omitempty"`

	// CurrentTypeID The supply type reference ID (e.g. DC etc)
	CurrentTypeID *int `json:"CurrentTypeID,omitempty"`
	ID            *int `json:"ID,omitempty"`

	// Level A general category for equipment power capability. Deprecated for general use. Currently computed automatically based on equipment power.
	Level *LevelType `json:"Level,omitempty"`

	// LevelID A general category for power capability. Depreceated in favour of documenting specific equipment power in kW.
	// Deprecated:
	LevelID *int `json:"LevelID,omitempty"`

	// PowerKW Peak available power in kW
	PowerKW *float32 `json:"PowerKW,omitempty"`

	// Quantity Optional summary number of equipment items available with this specification
	Quantity *int `json:"Quantity,omitempty"`

	// Reference Optional operators reference for this connection/port
	Reference *string `json:"Reference,omitempty"`

	// StatusType The Status Type of a site or equipment item indicates whether it is generally operational.
	StatusType *StatusType `json:"StatusType,omitempty"`

	// StatusTypeID Status Type reference ID. 0 = Unknown
	StatusTypeID *int `json:"StatusTypeID,omitempty"`

	// Voltage EVSE supply voltage
	Voltage *float32 `json:"Voltage,omitempty"`
}

// ConnectionType The type of end-user connection an EVSE supports.
type ConnectionType struct {
	// FormalName Formal (standard) name for this connection type
	FormalName *string `json:"FormalName,omitempty"`
	ID         *int    `json:"ID,omitempty"`

	// IsDiscontinued If true, this is an discontinued but used connection type
	IsDiscontinued *bool `json:"IsDiscontinued,omitempty"`

	// IsObsolete If true, this is an obsolete connection type and is unlikely top be present in modern infrastructure
	IsObsolete *bool   `json:"IsObsolete,omitempty"`
	Title      *string `json:"Title,omitempty"`
}

// CoreReferenceData Set of core reference data used for other API results and UI
type CoreReferenceData struct {
	ChargerTypes          *[]LevelType            `json:"ChargerTypes,omitempty"`
	CheckinStatusTypes    *[]CheckinStatusType    `json:"CheckinStatusTypes,omitempty"`
	ConnectionTypes       *[]ConnectionType       `json:"ConnectionTypes,omitempty"`
	Countries             *[]Country              `json:"Countries,omitempty"`
	CurrentTypes          *[]SupplyType           `json:"CurrentTypes,omitempty"`
	DataProviders         *[]DataProvider         `json:"DataProviders,omitempty"`
	DataTypes             *interface{}            `json:"DataTypes,omitempty"`
	MetadataGroups        *string                 `json:"MetadataGroups,omitempty"`
	Operators             *[]OperatorInfo         `json:"Operators,omitempty"`
	StatusTypes           *[]StatusType           `json:"StatusTypes,omitempty"`
	SubmissionStatusTypes *[]SubmissionStatusType `json:"SubmissionStatusTypes,omitempty"`
	UsageTypes            *[]UsageType            `json:"UsageTypes,omitempty"`
	UserCommentTypes      *[]UserCommentType      `json:"UserCommentTypes,omitempty"`
}

// Country Country details
type Country struct {
	// ContinentCode The Continentcode Schema
	ContinentCode string `json:"ContinentCode"`

	// ID The Id Schema
	ID int `json:"ID"`

	// ISOCode The Isocode Schema
	ISOCode string `json:"ISOCode"`

	// Title The Title Schema
	Title *string `json:"Title,omitempty"`
}

// DataProvider A Data Provider is the controller of the source data set used to construct the details for this POI. Data has been transformed and interpreted from it's original form. Each Data Provider provides data either by an explicit license or agreement.
type DataProvider struct {
	// Comments General public comments with information about this Data Provider.
	Comments *string `json:"Comments,omitempty"`

	// DataProviderStatusType Status object describing whether this data provider is currently enabled and the type of source (manual entry, imported etc)
	DataProviderStatusType *struct {
		// ID The reference ID for this provider status type
		ID int `json:"ID"`

		// IsProviderEnabled If false, results from this data provider are not currently enabled
		IsProviderEnabled bool `json:"IsProviderEnabled"`

		// Description The Title of this status type
		Description *string `json:"description,omitempty"`
	} `json:"DataProviderStatusType,omitempty"`

	// DateLastImported Date and time (UTC) the last import was performed for this data provider (if an import).
	DateLastImported *time.Time `json:"DateLastImported,omitempty"`

	// ID The reference ID for this Data Provider
	ID int `json:"ID"`

	// IsApprovedImport If false, data may not be imported for this provider.
	IsApprovedImport *bool `json:"IsApprovedImport,omitempty"`

	// IsOpenDataLicensed If true, data provider uses an Open Data license
	IsOpenDataLicensed *bool `json:"IsOpenDataLicensed,omitempty"`

	// IsRestrictedEdit Currently not implemented. Indicates a potential editing restriction.
	IsRestrictedEdit bool `json:"IsRestrictedEdit"`

	// License Summary of the licensing which applies for this Data Provider. Each Data Provider has one specific license or agreement. Usage of the data requires acceptance of the given license.
	License *string `json:"License,omitempty"`

	// Title The Title for this Data Provider
	Title *string `json:"Title,omitempty"`

	// WebsiteURL Website URL for this data provider
	WebsiteURL *string `json:"WebsiteURL,omitempty"`
}

// LevelType A general category for equipment power capability. Deprecated for general use. Currently computed automatically based on equipment power.
type LevelType struct {
	Comments string `json:"Comments"`
	ID       int    `json:"ID"`

	// IsFastChargeCapable If true, this level is considered 'fast' charging, relative to other levels.
	IsFastChargeCapable bool    `json:"IsFastChargeCapable"`
	Title               *string `json:"Title,omitempty"`
}

// MediaItem A user submitted media item related to a specific charge point or site. Currently always an image.
type MediaItem struct {
	ChargePointID      *int64 `json:"ChargePointID,omitempty"`
	Comment            *string `json:"Comment,omitempty"`
	DateCreated        *string `json:"DateCreated,omitempty"`
	ID                 *int64 `json:"ID,omitempty"`
	IsEnabled          *bool   `json:"IsEnabled,omitempty"`
	IsExternalResource *bool   `json:"IsExternalResource,omitempty"`
	IsFeaturedItem     *bool   `json:"IsFeaturedItem,omitempty"`
	IsVideo            *bool   `json:"IsVideo,omitempty"`
	ItemThumbnailURL   *string `json:"ItemThumbnailURL,omitempty"`
	ItemURL            *string `json:"ItemURL,omitempty"`

	// User Short public summary profile for a specific Open Charge Map user
	User *UserInfo `json:"User,omitempty"`
}

// OperatorInfo An Operator is the public organisation which controls a network of charging points.
type OperatorInfo struct {
	// AddressInfo Geographic position for site and (nearest) address component information.
	AddressInfo  *AddressInfo `json:"AddressInfo,omitempty"`
	BookingURL   *string      `json:"BookingURL,omitempty"`
	Comments     *string      `json:"Comments,omitempty"`
	ContactEmail *string      `json:"ContactEmail,omitempty"`

	// FaultReportEmail Used to send automated notification to network operator if a user submits a fault report comment/check-in
	FaultReportEmail *string `json:"FaultReportEmail,omitempty"`

	// ID Id
	ID int `json:"ID"`

	// IsPrivateIndividual If true, this operator represents a private individual
	// Deprecated:
	IsPrivateIndividual *bool `json:"IsPrivateIndividual,omitempty"`

	// IsRestrictedEdit If true, this network restricts community edits for OCM data
	IsRestrictedEdit *bool `json:"IsRestrictedEdit,omitempty"`

	// PhonePrimaryContact Primary contact number for network users
	PhonePrimaryContact *string `json:"PhonePrimaryContact,omitempty"`

	// PhoneSecondaryContact Secondary contact number
	PhoneSecondaryContact *string `json:"PhoneSecondaryContact,omitempty"`

	// Title Title
	Title *string `json:"Title,omitempty"`

	// WebsiteURL Website for more information about this network
	WebsiteURL *string `json:"WebsiteURL,omitempty"`
}

// ChargePoint A POI (Point of Interest), also referred to as a `Site` or `ChargePoint`, is the top-level set of information regarding a geographic site with one or more electric vehicle charging equipment present. The term `ChargePointID` is used to reference the unique ID for each POI, as called OCM ID. This reference appears in various UI elements in the format `OCM-12345` to distinguish the ID number as being a reference for a specific POI/site.
//
// Note: If the API is called in verbose mode properties expanded properties are included in the results (e.g. UsageType, StatusType, DataProvider, OperatorInfo, SubmissionStatus).  With the exception of the AddressInfo property, other object properties will not be populated in a compact result set and instead only the associated reference IDs will be set (e.g. UsageTypeID, DataProviderID etc)
type ChargePoint struct {
	// AddressInfo Geographic position for site and (nearest) address component information.
	AddressInfo *AddressInfo `json:"AddressInfo,omitempty"`

	// Connections List of equipment summary information for this site
	Connections *[]ConnectionInfo `json:"Connections,omitempty"`

	// DataProvider A Data Provider is the controller of the source data set used to construct the details for this POI. Data has been transformed and interpreted from it's original form. Each Data Provider provides data either by an explicit license or agreement.
	DataProvider *DataProvider `json:"DataProvider,omitempty"`

	// DataProviderID The reference ID for the Data Provider of this POI
	DataProviderID *int `json:"DataProviderID,omitempty"`

	// DataProvidersReference If present, this is the Data Providers own key for this POI within their source data set
	DataProvidersReference *string `json:"DataProvidersReference,omitempty"`

	// DataQualityLevel A metric applied during imports to indicate a quality level based on available information detail (5 == best). Largely unused currently.
	DataQualityLevel *int `json:"DataQualityLevel,omitempty"`

	// DateCreated The date and time (UTC, ISO 8601) this POI was added to the Open Charge Map database
	DateCreated *time.Time `json:"DateCreated,omitempty"`

	// DateLastConfirmed The date and time (UTC, ISO 8601) this POI was last confirmed according to the data provider or a user. See DateLastVerified for a dynamically computed date based on multiple signals.
	DateLastConfirmed *time.Time `json:"DateLastConfirmed,omitempty"`

	// DateLastStatusUpdate The date and time (UTC, ISO 8601) this POI or directly related child properties were updated.
	DateLastStatusUpdate *time.Time `json:"DateLastStatusUpdate,omitempty"`

	// DateLastVerified A dynamically computed value, the date and time (UTC, ISO 8601) this POI was last confirmed by a user edit or related user comment
	DateLastVerified *time.Time `json:"DateLastVerified,omitempty"`

	// DatePlanned The date and time (UTC, ISO 8601) this POI is or was planned for commissioning. In general planned POIs should not be presented to end users until confirmed operational.
	DatePlanned *time.Time `json:"DatePlanned,omitempty"`

	// GeneralComments General additional factual information for the POI. Users are discouraged from using this field for opinions on site quality etc.
	GeneralComments *string `json:"GeneralComments,omitempty"`

	// ID The OCM reference ID for this POI (Point of Interest).
	ID *int `json:"ID,omitempty"`

	// IsRecentlyVerified A dynamically computed value indicating of any recently confirmation activity has taken place for this site (positive check-ins etc)
	IsRecentlyVerified *bool `json:"IsRecentlyVerified,omitempty"`

	// MediaItems A list of user submitted photos for this site
	MediaItems *[]MediaItem `json:"MediaItems,omitempty"`

	// MetadataValues Optional array of metadata values. Generally used to indicate data attribution but is also intended for future use to indicate surrounding amenties, links or foreign key values into other data sets.
	MetadataValues *[]interface{} `json:"MetadataValues,omitempty"`

	// NumberOfPoints The number of bays or discreet stations available overall at this site. This indicates the limiting for number of simultaneous site users.
	NumberOfPoints *int `json:"NumberOfPoints,omitempty"`

	// OperatorID The reference ID of the equipment network operator or owner
	OperatorID *int `json:"OperatorID,omitempty"`

	// OperatorInfo An Operator is the public organisation which controls a network of charging points.
	OperatorInfo *OperatorInfo `json:"OperatorInfo,omitempty"`

	// OperatorsReference The network operators own reference for this site (may be a site reference or a single equipment reference)
	OperatorsReference *string `json:"OperatorsReference,omitempty"`

	// ParentChargePointID If present, this data in this POI supercedes information in another POI. Generally not relevant to consumers.
	ParentChargePointID *int `json:"ParentChargePointID,omitempty"`

	// StatusType The Status Type of a site or equipment item indicates whether it is generally operational.
	StatusType *StatusType `json:"StatusType,omitempty"`

	// StatusTypeID The overall operational status type reference ID for this POI (i.e. Operational etc). 0 == Unknown
	StatusTypeID *int `json:"StatusTypeID,omitempty"`

	// SubmissionStatus Submission Status object, detailing the POI listing status
	SubmissionStatus *SubmissionStatusType `json:"SubmissionStatus,omitempty"`

	// SubmissionStatusTypeID The reference ID for the submission status type which applied to this POI.
	SubmissionStatusTypeID *int `json:"SubmissionStatusTypeID,omitempty"`

	// UUID A universally unique identifier used as surrogate key. ID and UUID must be preserved when submitting POI update information.
	UUID *openapi_types.UUID `json:"UUID,omitempty"`

	// UsageCost Free text description of likely usage costs associated with this site. Generally relates to parking charges whether network operates this site as Free
	UsageCost *string `json:"UsageCost,omitempty"`

	// UsageType The Usage Type of a site indicates the general restrictions on usage.
	UsageType *UsageType `json:"UsageType,omitempty"`

	// UsageTypeID The reference ID for the site Usage Type, 0 == Unknown
	UsageTypeID *int `json:"UsageTypeID,omitempty"`

	// UserComments A list of user comments or check-ins for this site
	UserComments *[]UserComment `json:"UserComments,omitempty"`
}

// StatusType The Status Type of a site or equipment item indicates whether it is generally operational.
type StatusType struct {
	ID               int     `json:"ID"`
	IsOperational    bool    `json:"IsOperational"`
	IsUserSelectable bool    `json:"IsUserSelectable"`
	Title            *string `json:"Title,omitempty"`
}

// SubmissionStatusType Submission Status object, detailing the POI listing status
type SubmissionStatusType struct {
	// ID Submission Status Type reference ID
	ID int `json:"ID"`

	// IsLive If true, POI listing is live (not draft or de-listed)
	IsLive bool    `json:"IsLive"`
	Title  *string `json:"Title,omitempty"`
}

// SupplyType Indicates the EVSE power supply type e.g. DC (Direct Current), AC (Single Phase), AC (3 Phase).
type SupplyType struct {
	ID    int     `json:"ID"`
	Title *string `json:"Title,omitempty"`
}

// UsageType The Usage Type of a site indicates the general restrictions on usage.
type UsageType struct {
	ID int `json:"ID"`

	// IsAccessKeyRequired If true this usage required a physical access key
	// Deprecated:
	IsAccessKeyRequired bool `json:"IsAccessKeyRequired"`

	// IsMembershipRequired If true, this usage type requires registration or membership with a service.
	IsMembershipRequired bool `json:"IsMembershipRequired"`

	// IsPayAtLocation If true, usage requires paying at location
	IsPayAtLocation bool    `json:"IsPayAtLocation"`
	Title           *string `json:"Title,omitempty"`
}

// UserComment A user comment or check-in for a specific charging point (POI/Site)
type UserComment struct {
	ChargePointID *int `json:"ChargePointID,omitempty"`

	// CheckinStatusType Classification for the users comment or experience using a specific charging location.
	CheckinStatusType   *CheckinStatusType `json:"CheckinStatusType,omitempty"`
	CheckinStatusTypeID *int               `json:"CheckinStatusTypeID,omitempty"`
	Comment             *string            `json:"Comment,omitempty"`

	// CommentType Category for a user comment, e.g. General Comment, Fault Report (Notice To Users And Operator)
	CommentType   *UserCommentType `json:"CommentType,omitempty"`
	CommentTypeID *int             `json:"CommentTypeID,omitempty"`
	DateCreated   *time.Time       `json:"DateCreated,omitempty"`
	ID            *int          `json:"ID,omitempty"`
	RelatedURL    *string          `json:"RelatedURL,omitempty"`

	// User Short public summary profile for a specific Open Charge Map user
	User     *UserInfo `json:"User,omitempty"`
	UserName *string   `json:"UserName,omitempty"`
}

// UserCommentType Category for a user comment, e.g. General Comment, Fault Report (Notice To Users And Operator)
type UserCommentType struct {
	ID    *int    `json:"ID,omitempty"`
	Title *string `json:"Title,omitempty"`
}

// UserInfo Short public summary profile for a specific Open Charge Map user
type UserInfo struct {
	ID               *int    `json:"ID,omitempty"`
	ProfileImageURL  *string `json:"ProfileImageURL,omitempty"`
	ReputationPoints *int    `json:"ReputationPoints,omitempty"`
	Username         *string `json:"Username,omitempty"`
}

// UserProfile Full user profile, including non-public fields such as Email Address
type UserProfile struct {
	DateCreated      string   `json:"DateCreated"`
	DateLastLogin    *string  `json:"DateLastLogin,omitempty"`
	EmailAddress     *string  `json:"EmailAddress,omitempty"`
	ID               float32  `json:"ID"`
	IsProfilePublic  bool     `json:"IsProfilePublic"`
	Latitude         *float32 `json:"Latitude,omitempty"`
	Location         *string  `json:"Location,omitempty"`
	Longitude        *float32 `json:"Longitude,omitempty"`
	Permissions      *string  `json:"Permissions,omitempty"`
	Profile          *string  `json:"Profile,omitempty"`
	ProfileImageURL  *string  `json:"ProfileImageURL,omitempty"`
	ReputationPoints *float32 `json:"ReputationPoints,omitempty"`
	Username         string   `json:"Username"`
	WebsiteURL       *string  `json:"WebsiteURL,omitempty"`
}

// POI defines model for POI.
type POI = []ChargePoint

// PostCommentJSONBody defines parameters for PostComment.
type PostCommentJSONBody struct {
	// ChargePointID This must be a valid POI ID
	ChargePointID int `json:"chargePointID"`

	// CheckinStatusTypeID Optional valid CheckStatusTypeID to indicate overall catgeory and success/failure to use equipment e.g. 10 = Charged Successfully.
	CheckinStatusTypeID *int `json:"checkinStatusTypeID,omitempty"`

	// Comment This is an optional comment to describe the charging experience, may include guidance for future users.
	Comment *string `json:"comment,omitempty"`

	// CommentTypeID This must be a valid Comment Type ID as per UserCommentTypes found in Core Reference Data. If left as null then General Comment will be used.
	CommentTypeID *int `json:"commentTypeID,omitempty"`

	// Rating Optional integer rating between 1 = Worst, 5 = Best.
	Rating *int `json:"rating,omitempty"`

	// RelatedURL Optional website URL for related information
	RelatedURL *string `json:"relatedURL,omitempty"`

	// UserName This is an optional name to associate with the submission, for authenticated users their profile username is used.
	UserName *string `json:"userName,omitempty"`
}

// PostMediaitemJSONBody defines parameters for PostMediaitem.
type PostMediaitemJSONBody struct {
	// ChargePointID ID value for the OCM site (POI) this image relates to.
	ChargePointID int `json:"chargePointID"`

	// Comment Optional description of image or context
	Comment *string `json:"comment,omitempty"`

	// ImageDataBase64 BASE64 encoded data
	ImageDataBase64 string `json:"imageDataBase64"`
}

// GetPoiParams defines parameters for GetPoi.
type GetPoiParams struct {
	// Output Optional output format `json`,`geojson`,`xml`,`csv`, JSON is the default and recommended as the highest fidelity.
	Output *string `form:"output,omitempty" json:"output,omitempty"`

	// Client String to identify your client application. Optional but recommended to distinguish your client from other bots/crawlers
	Client *string `form:"client,omitempty" json:"client,omitempty"`

	// Maxresults Limit on max number of results returned
	Maxresults *int `form:"maxresults,omitempty" json:"maxresults,omitempty"`

	// Countrycode 2-character ISO Country code to filter to one specific country
	Countrycode *string `form:"countrycode,omitempty" json:"countrycode,omitempty"`

	// Countryid Exact match on a given numeric country id (comma separated list)
	Countryid *[]string `form:"countryid,omitempty" json:"countryid,omitempty"`

	// Latitude Latitude for distance calculation and filtering
	Latitude *int `form:"latitude,omitempty" json:"latitude,omitempty"`

	// Longitude Longitude for distance calculation and filtering
	Longitude *float32 `form:"longitude,omitempty" json:"longitude,omitempty"`

	// Distance Optionally filter results by a max distance from the given latitude/longitude
	Distance *float32 `form:"distance,omitempty" json:"distance,omitempty"`

	// Distanceunit `miles` or `km` distance unit
	Distanceunit *string `form:"distanceunit,omitempty" json:"distanceunit,omitempty"`

	// Operatorid Exact match on a given EVSE operator id (comma separated list)
	Operatorid *[]interface{} `form:"operatorid,omitempty" json:"operatorid,omitempty"`

	// Connectiontypeid Exact match on a given connection type id (comma separated list)
	Connectiontypeid *[]interface{} `form:"connectiontypeid,omitempty" json:"connectiontypeid,omitempty"`

	// Levelid Exact match on a given charging level (1-3) id (comma separated list)
	Levelid *[]interface{} `form:"levelid,omitempty" json:"levelid,omitempty"`

	// Usagetypeid Exact match on a given usage type id (comma separated list)
	Usagetypeid *[]interface{} `form:"usagetypeid,omitempty" json:"usagetypeid,omitempty"`

	// Statustypeid Exact match on a given status type id (comma separated list)
	Statustypeid *[]interface{} `form:"statustypeid,omitempty" json:"statustypeid,omitempty"`

	// Dataproviderid Exact match on a given data provider id id (comma separated list).
	Dataproviderid *[]interface{} `form:"dataproviderid,omitempty" json:"dataproviderid,omitempty"`

	// Opendata Use opendata=true for only OCM provided ("Open") data.
	Opendata *bool `form:"opendata,omitempty" json:"opendata,omitempty"`

	// Includecomments If true, user comments and media items will be include in result set
	Includecomments *bool `form:"includecomments,omitempty" json:"includecomments,omitempty"`

	// Verbose Set to false to get a smaller result set with null items removed.
	Verbose *bool `form:"verbose,omitempty" json:"verbose,omitempty"`

	// Compact Set to true to remove reference data objects from output (just returns IDs for common reference data such as DataProvider etc).
	Compact *bool `form:"compact,omitempty" json:"compact,omitempty"`

	// Camelcase Set to true to get a property names in camelCase format.
	Camelcase *bool `form:"camelcase,omitempty" json:"camelcase,omitempty"`

	// Chargepointid Exact match on a given OCM POI ID (comma separated list)
	Chargepointid *string `form:"chargepointid,omitempty" json:"chargepointid,omitempty"`

	// Boundingbox Filter results to a given bounding box. specify top left and bottom right box corners as: (lat,lng),(lat2,lng2)
	Boundingbox *string `form:"boundingbox,omitempty" json:"boundingbox,omitempty"`

	// Polygon Filter results within a given Polygon. Specify an encoded polyline for the polygon shape. Polygon will be automatically closed from the last point to the first point.
	Polygon *string `form:"polygon,omitempty" json:"polygon,omitempty"`

	// Polyline Filter results along an encoded polyline, use with distance param to increase search distance along line. Polyline is expanded into a polygon to cover the search distance.
	Polyline *string `form:"polyline,omitempty" json:"polyline,omitempty"`
}

// PostAuthenticateJSONBody defines parameters for PostAuthenticate.
type PostAuthenticateJSONBody struct {
	Emailaddress *string `json:"emailaddress,omitempty"`
	Password     *string `json:"password,omitempty"`
}

// GetReferencedataParams defines parameters for GetReferencedata.
type GetReferencedataParams struct {
	// Countryid Optional filter on countryid, exact match on a given numeric country id (comma separated list)
	Countryid *[]interface{} `form:"countryid,omitempty" json:"countryid,omitempty"`
}

// PostCommentJSONRequestBody defines body for PostComment for application/json ContentType.
type PostCommentJSONRequestBody PostCommentJSONBody

// PostMediaitemJSONRequestBody defines body for PostMediaitem for application/json ContentType.
type PostMediaitemJSONRequestBody PostMediaitemJSONBody

// PostAuthenticateJSONRequestBody defines body for PostAuthenticate for application/json ContentType.
type PostAuthenticateJSONRequestBody PostAuthenticateJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostCommentWithBody request with any body
	PostCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostComment(ctx context.Context, body PostCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMediaitemWithBody request with any body
	PostMediaitemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMediaitem(ctx context.Context, body PostMediaitemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenapi request
	GetOpenapi(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPoi request
	GetPoi(ctx context.Context, params *GetPoiParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthenticateWithBody request with any body
	PostAuthenticateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthenticate(ctx context.Context, body PostAuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReferencedata request
	GetReferencedata(ctx context.Context, params *GetReferencedataParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCommentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostComment(ctx context.Context, body PostCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCommentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMediaitemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMediaitemRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMediaitem(ctx context.Context, body PostMediaitemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMediaitemRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenapi(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPoi(ctx context.Context, params *GetPoiParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPoiRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthenticateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthenticateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthenticate(ctx context.Context, body PostAuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthenticateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReferencedata(ctx context.Context, params *GetReferencedataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReferencedataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostCommentRequest calls the generic PostComment builder with application/json body
func NewPostCommentRequest(server string, body PostCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCommentRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCommentRequestWithBody generates requests for PostComment with any type of body
func NewPostCommentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/comment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostMediaitemRequest calls the generic PostMediaitem builder with application/json body
func NewPostMediaitemRequest(server string, body PostMediaitemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMediaitemRequestWithBody(server, "application/json", bodyReader)
}

// NewPostMediaitemRequestWithBody generates requests for PostMediaitem with any type of body
func NewPostMediaitemRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mediaitem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOpenapiRequest generates requests for GetOpenapi
func NewGetOpenapiRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPoiRequest generates requests for GetPoi
func NewGetPoiRequest(server string, params *GetPoiParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/poi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Output != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "output", runtime.ParamLocationQuery, *params.Output); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Client != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client", runtime.ParamLocationQuery, *params.Client); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Maxresults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxresults", runtime.ParamLocationQuery, *params.Maxresults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Countrycode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "countrycode", runtime.ParamLocationQuery, *params.Countrycode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Countryid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "countryid", runtime.ParamLocationQuery, *params.Countryid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Latitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "latitude", runtime.ParamLocationQuery, *params.Latitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Longitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "longitude", runtime.ParamLocationQuery, *params.Longitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Distance != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "distance", runtime.ParamLocationQuery, *params.Distance); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Distanceunit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "distanceunit", runtime.ParamLocationQuery, *params.Distanceunit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Operatorid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operatorid", runtime.ParamLocationQuery, *params.Operatorid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Connectiontypeid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "connectiontypeid", runtime.ParamLocationQuery, *params.Connectiontypeid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Levelid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "levelid", runtime.ParamLocationQuery, *params.Levelid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Usagetypeid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "usagetypeid", runtime.ParamLocationQuery, *params.Usagetypeid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statustypeid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statustypeid", runtime.ParamLocationQuery, *params.Statustypeid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dataproviderid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dataproviderid", runtime.ParamLocationQuery, *params.Dataproviderid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Opendata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opendata", runtime.ParamLocationQuery, *params.Opendata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includecomments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includecomments", runtime.ParamLocationQuery, *params.Includecomments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Verbose != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "verbose", runtime.ParamLocationQuery, *params.Verbose); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Compact != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "compact", runtime.ParamLocationQuery, *params.Compact); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Camelcase != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "camelcase", runtime.ParamLocationQuery, *params.Camelcase); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Chargepointid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chargepointid", runtime.ParamLocationQuery, *params.Chargepointid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Boundingbox != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "boundingbox", runtime.ParamLocationQuery, *params.Boundingbox); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Polygon != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polygon", runtime.ParamLocationQuery, *params.Polygon); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Polyline != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polyline", runtime.ParamLocationQuery, *params.Polyline); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAuthenticateRequest calls the generic PostAuthenticate builder with application/json body
func NewPostAuthenticateRequest(server string, body PostAuthenticateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthenticateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAuthenticateRequestWithBody generates requests for PostAuthenticate with any type of body
func NewPostAuthenticateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/authenticate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReferencedataRequest generates requests for GetReferencedata
func NewGetReferencedataRequest(server string, params *GetReferencedataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/referencedata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Countryid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "countryid", runtime.ParamLocationQuery, *params.Countryid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostCommentWithBodyWithResponse request with any body
	PostCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCommentResponse, error)

	PostCommentWithResponse(ctx context.Context, body PostCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCommentResponse, error)

	// PostMediaitemWithBodyWithResponse request with any body
	PostMediaitemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMediaitemResponse, error)

	PostMediaitemWithResponse(ctx context.Context, body PostMediaitemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMediaitemResponse, error)

	// GetOpenapiWithResponse request
	GetOpenapiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiResponse, error)

	// GetPoiWithResponse request
	GetPoiWithResponse(ctx context.Context, params *GetPoiParams, reqEditors ...RequestEditorFn) (*GetPoiResponse, error)

	// PostAuthenticateWithBodyWithResponse request with any body
	PostAuthenticateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthenticateResponse, error)

	PostAuthenticateWithResponse(ctx context.Context, body PostAuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthenticateResponse, error)

	// GetReferencedataWithResponse request
	GetReferencedataWithResponse(ctx context.Context, params *GetReferencedataParams, reqEditors ...RequestEditorFn) (*GetReferencedataResponse, error)
}

type PostCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Description string `json:"description"`
		Status      string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r PostCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMediaitemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Description *string `json:"description,omitempty"`

		// Status status code OK
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r PostMediaitemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMediaitemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenapiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenapiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPoiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *POI
}

// Status returns HTTPResponse.Status
func (r GetPoiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPoiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthenticateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			// UserProfile Full user profile, including non-public fields such as Email Address
			UserProfile UserProfile `json:"UserProfile"`

			// AccessToken JWT Bearer Token to use in subsequent authenticated requests
			AccessToken string `json:"access_token"`
		} `json:"Data"`
		Metadata struct {
			StatusCode int `json:"StatusCode"`
		} `json:"Metadata"`
	}
}

// Status returns HTTPResponse.Status
func (r PostAuthenticateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthenticateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReferencedataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoreReferenceData
}

// Status returns HTTPResponse.Status
func (r GetReferencedataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReferencedataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostCommentWithBodyWithResponse request with arbitrary body returning *PostCommentResponse
func (c *ClientWithResponses) PostCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCommentResponse, error) {
	rsp, err := c.PostCommentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCommentResponse(rsp)
}

func (c *ClientWithResponses) PostCommentWithResponse(ctx context.Context, body PostCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCommentResponse, error) {
	rsp, err := c.PostComment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCommentResponse(rsp)
}

// PostMediaitemWithBodyWithResponse request with arbitrary body returning *PostMediaitemResponse
func (c *ClientWithResponses) PostMediaitemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMediaitemResponse, error) {
	rsp, err := c.PostMediaitemWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMediaitemResponse(rsp)
}

func (c *ClientWithResponses) PostMediaitemWithResponse(ctx context.Context, body PostMediaitemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMediaitemResponse, error) {
	rsp, err := c.PostMediaitem(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMediaitemResponse(rsp)
}

// GetOpenapiWithResponse request returning *GetOpenapiResponse
func (c *ClientWithResponses) GetOpenapiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiResponse, error) {
	rsp, err := c.GetOpenapi(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiResponse(rsp)
}

// GetPoiWithResponse request returning *GetPoiResponse
func (c *ClientWithResponses) GetPoiWithResponse(ctx context.Context, params *GetPoiParams, reqEditors ...RequestEditorFn) (*GetPoiResponse, error) {
	rsp, err := c.GetPoi(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPoiResponse(rsp)
}

// PostAuthenticateWithBodyWithResponse request with arbitrary body returning *PostAuthenticateResponse
func (c *ClientWithResponses) PostAuthenticateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthenticateResponse, error) {
	rsp, err := c.PostAuthenticateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthenticateResponse(rsp)
}

func (c *ClientWithResponses) PostAuthenticateWithResponse(ctx context.Context, body PostAuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthenticateResponse, error) {
	rsp, err := c.PostAuthenticate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthenticateResponse(rsp)
}

// GetReferencedataWithResponse request returning *GetReferencedataResponse
func (c *ClientWithResponses) GetReferencedataWithResponse(ctx context.Context, params *GetReferencedataParams, reqEditors ...RequestEditorFn) (*GetReferencedataResponse, error) {
	rsp, err := c.GetReferencedata(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReferencedataResponse(rsp)
}

// ParsePostCommentResponse parses an HTTP response from a PostCommentWithResponse call
func ParsePostCommentResponse(rsp *http.Response) (*PostCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Description string `json:"description"`
			Status      string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostMediaitemResponse parses an HTTP response from a PostMediaitemWithResponse call
func ParsePostMediaitemResponse(rsp *http.Response) (*PostMediaitemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMediaitemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Description *string `json:"description,omitempty"`

			// Status status code OK
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOpenapiResponse parses an HTTP response from a GetOpenapiWithResponse call
func ParseGetOpenapiResponse(rsp *http.Response) (*GetOpenapiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPoiResponse parses an HTTP response from a GetPoiWithResponse call
func ParseGetPoiResponse(rsp *http.Response) (*GetPoiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPoiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest POI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAuthenticateResponse parses an HTTP response from a PostAuthenticateWithResponse call
func ParsePostAuthenticateResponse(rsp *http.Response) (*PostAuthenticateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthenticateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				// UserProfile Full user profile, including non-public fields such as Email Address
				UserProfile UserProfile `json:"UserProfile"`

				// AccessToken JWT Bearer Token to use in subsequent authenticated requests
				AccessToken string `json:"access_token"`
			} `json:"Data"`
			Metadata struct {
				StatusCode int `json:"StatusCode"`
			} `json:"Metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetReferencedataResponse parses an HTTP response from a GetReferencedataWithResponse call
func ParseGetReferencedataResponse(rsp *http.Response) (*GetReferencedataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReferencedataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoreReferenceData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
